#!/usr/bin/env sh
set -e

# Configuration                                                         {{{
# --------------------------------------------------------------------- {|}

if [ -z "$GIT_MUX_SELECT_CMD" ] && ! command -v fzf >/dev/null 2>&1; then
    printf "%s\n%s\n%s\n" \
        "Error: install fzf or specify a different method for" \
        "selection with the GIT_MUX_SELECT_CMD environment variable." \
        "See the ENVIRONMENT section of \`man git mux\` for details." >&2
    exit 1
fi

GIT_MUX_BRANCH_PREFIX=${GIT_MUX_BRANCH_PREFIX:-}

GIT_MUX_SELECT_CMD=${GIT_MUX_SELECT_CMD:-fzf --reverse}

GIT_MUX_PROJECT_PARENTS=${GIT_MUX_PROJECT_PARENTS:-${PROJECTS:-$HOME}}

GIT_MUX_PROJECTS=${GIT_MUX_PROJECTS:-$(
    for project_parent_dir in $GIT_MUX_PROJECT_PARENTS; do
        for project_dir in "$project_parent_dir"/*; do
            if [ -d "$project_dir" ]; then
                printf "%s " "$project_dir"
            fi
        done
    done
    # The mess above is a compliant solution to:
    # find $GIT_MUX_PROJECT_PARENTS -maxdepth 1 -mindepth 1 -type d
)}

if [ "$GIT_MUX_LOGS" = "1" ]; then
    if [ -d "$HOME/.git-mux" ]; then
        GIT_MUX_LOGS="$HOME/.git-mux/logs"
    elif [ -d "$XDG_STATE_HOME" ]; then
        GIT_MUX_LOGS="$XDG_STATE_HOME/git-mux/logs"
    else
        GIT_MUX_LOGS="$HOME/.local/state/git-mux/logs"
    fi
fi

[ -n "$GIT_MUX_LOGS" ] && [ "$GIT_MUX_LOGS" != "0" ] &&
    mkdir -p "$(dirname "$GIT_MUX_LOGS")"

# --------------------------------------------------------------------- }}}
# Usage info and logs                                                   {{{
# --------------------------------------------------------------------- {|}
help() {
    if [ -z "$1" ]; then
        man git-mux
        exit 1
    fi
}

logger() {
    if [ -n "$GIT_MUX_LOGS" ] && [ "$GIT_MUX_LOGS" != "0" ]; then
        printf "%s | %s | %s" \
            "$1" \
            "$(date +%Y-%m-%dT%H:%M:%S 2>/dev/null)" \
            "$2" \
            >>"$GIT_MUX_LOGS"
    fi
}

log_config_values() {
    cat <<EOF
========= GIT_MUX_PROJECT_PARENTS =========
$GIT_MUX_PROJECT_PARENTS

========= GIT_MUX_PROJECTS =========
$GIT_MUX_PROJECTS

========= GIT_MUX_SELECT_CMD =========
$GIT_MUX_SELECT_CMD

========= GIT_MUX_BRANCH_PREFIX =========
$GIT_MUX_BRANCH_PREFIX

========= GIT_MUX_NEW_WORKTREE_CMD =========
$GIT_MUX_NEW_WORKTREE_CMD

========= GIT_MUX_LOGS =========
$GIT_MUX_LOGS

EOF
    exit 0
}

# --------------------------------------------------------------------- }}}
# Util functions                                                        {{{
# --------------------------------------------------------------------- {|}

sanitize_name() {
    basename "$1" | tr "./" "__"
}

# tmux utils from https://github.com/thoughtbot/dotfiles/blob/main/bin/tat
tmux_session_exists() {
    tmux has-session -t "=$1" >/dev/null 2>&1
}

in_tmux() {
    [ -n "$TMUX" ]
}

has_tmux_server() {
    tmux run 2>/dev/null
}

tmux_create_if_needed_and_attach() {
    project_path="${1:-$PWD}"
    project_name="$(sanitize_name "$project_path")"
    if in_tmux; then
        if ! tmux_session_exists "$project_name"; then
            logger "INFO " "project > creating \"$project_name\" at path \"$project_path\""
            tmux new-session -Adc "$project_path" -s "$project_name"
        fi
        logger "INFO " "project > switching to \"$project_name\" at path \"$project_path\""
        tmux switch-client -t "$project_name"
    else
        logger "INFO " "project > creating or attaching to \"$project_name\" at path \"$project_path\""
        tmux new-session -As "$project_name" -c "$project_path"
    fi
    unset project_path project_name
}

has_tmux_server && GIT_MUX_TMUX_SESSION="$(tmux display-message -p "#S")"

# --------------------------------------------------------------------- }}}
# Clone command                                                         {{{
# --------------------------------------------------------------------- {|}

# Clones a bare repo for use with git-worktree and creates an
# initial worktree for the repo's default branch.
# https://git-scm.com/docs/git-worktree
bare_clone() {
    new_repo_dir="${2:-"$(basename "$1" .git)"}"
    mkdir -p "$new_repo_dir"
    cd "$new_repo_dir" || return

    logger "INFO " "clone > cloning bare repo for \"$1\" in \"$(pwd)\""
    git clone --bare "$1" .git
    git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    git fetch origin

    # 60% of the time, it works every time (requires an "origin" or "upstream" remote)
    default_branch="$(
        git remote show "$(
            git remote | grep -Eo "(upstream|origin)" | tail -1
        )" | grep "HEAD branch" | cut -d" " -f5
    )"

    logger "INFO " "clone > creating worktree for default branch: $default_branch"
    git worktree add "$default_branch" "$default_branch"
    cd "$default_branch" || return
    unset new_repo_dir default_branch
}

# --------------------------------------------------------------------- }}}
# Project command                                                       {{{
# --------------------------------------------------------------------- {|}

# See `git mux help config`
# shellcheck disable=2086
select_project() { printf "%s\n" $GIT_MUX_PROJECTS | $GIT_MUX_SELECT_CMD; }

# Creates or attaches to a tmux session for a project. If the following argument
# is a valid path, it is used for the project. Otherwise the user is prompted
# to select a project.
handle_project() {
    if [ -n "$1" ] && [ -d "$1" ]; then
        logger "INFO " "project > valid path provided: \"$1\""
        tmux_create_if_needed_and_attach "$1"
    else
        logger "INFO " "project > a valid path was not provided, interactively selecting a project"
        tmux_create_if_needed_and_attach "$(select_project)"
    fi
}

# --------------------------------------------------------------------- }}}
# Task command                                                          {{{
# --------------------------------------------------------------------- {|}

# Determines the absolute path of the selected or provided project.
find_project_directory() {
    logger "DEBUG" "task > checking project names for a match with the tmux session: \"$GIT_MUX_TMUX_SESSION\""
    # check if the tmux session name is one of the projects
    for project in $GIT_MUX_PROJECTS; do
        if [ "$(
            sanitize_name "$(basename "$project")"
        )" = "$GIT_MUX_TMUX_SESSION" ]; then
            logger "DEBUG" "task > found a matching project: \"$project\""
            echo "$project"
            unset project
            return
        fi
    done

    logger "WARN " "task > no matching project found"
    if [ "$(sanitize_name "$(basename ~)")" = "$GIT_MUX_TMUX_SESSION" ]; then
        logger "DEBUG" "task > currently in home session, interactively selecting a project"
        select_project && return
    else
        logger "DEBUG" "task > using current directory as project"
        pwd
    fi
}

# Attaches/switches to a tmux window. If the next argument is a valid path,
# the window is created in that directory. If there are arguments after the
# path, the following one is used as the tmux window name. The rest of the
# arguments are sent to the window and executed instead of attaching/switching.
# This allows you to execute commands in the background and continue working.
#
#
# If the initial argument isn't a valid path it is treated a a git branch and
# creates/switches to a corresponding git worktree (when relevant). If no
# argument is provided it prompts to select an existing branch.
#
# Examples:
#
# Install deps and start app in a new or preexisting tmux window named 'start'.
# $ git mux task packages/app start npm install && npm start
#
# Create/checkout branch in tmux window, creating a git worktree if relevant.
# Appends $GIT_MUX_BRANCH_PREFIX to the argument when creating a new branch.
# $ git mux task 123-fix-bug
#
# Uses $GIT_MUX_SELECT_CMD to select an existing branch.
# $ git mux t
handle_task() {
    logger "DEBUG" "task > args: $*"
    # Check if the provided argument is a valid path
    if [ -n "$1" ] && [ -d "$1" ]; then
        task_dir="$(cd "$1" && pwd)"
        task_name="${2:-"$(sanitize_name "$task_dir")"}"
    else
        git_task "$@"
        return 0
    fi

    logger "INFO " "task > creating new \"$task_name\" task in \"$task_dir\""
    # Not using new-window's -S flag for backwards compatibility
    if ! tmux list-windows | grep -q "$task_name"; then
        tmux new-window -dn "$task_name" -c "$task_dir"
    fi

    # if provided, execute commands in the tmux window for new worktrees
    if [ -n "$GIT_MUX_NEW_WORKTREE" ] && [ -n "$GIT_MUX_NEW_WORKTREE_CMD" ]; then
        logger "INFO " "task > executing GIT_MUX_NEW_WORKTREE_CMD: \"$GIT_MUX_NEW_WORKTREE_CMD\""
        tmux send-keys -t "$GIT_MUX_TMUX_SESSION:$task_name" \
            "$GIT_MUX_NEW_WORKTREE_CMD" Enter
        unset GIT_MUX_NEW_WORKTREE
    fi

    # Attach, switch, or send keys to the new task
    if [ -n "$3" ]; then
        shift 2
        logger "INFO " "task > executing command (not attaching/switching tmux windows): \"$*\""
        tmux send-keys -t "$GIT_MUX_TMUX_SESSION:$task_name" "$*" Enter
    elif [ -n "$TMUX" ]; then
        logger "INFO " "task > switching tmux client"
        tmux switch-client -t "$GIT_MUX_TMUX_SESSION:$task_name"
    else
        logger "INFO " "task > attaching to tmux session"
        tmux attach -t "$GIT_MUX_TMUX_SESSION:$task_name"
    fi

    unset task_name task_dir
}

# The logic that handles the git portion of the 'task' subcommand.
# See handle_task documentation above for more info.
git_task() {
    task_start_dir="$(find_project_directory)"

    logger "INFO " "task > project's directory: $task_start_dir"
    cd "$task_start_dir" || return 1

    if is_git_root_dir "$task_start_dir"; then
        if [ -n "$1" ]; then
            task_branch="$1"
            shift
            logger "INFO " "task > provided branch: $task_branch"

            if ! git show-ref --verify --quiet "refs/heads/$task_branch"; then
                task_branch_flags="-b"

                logger "DEBUG" "task > branch not found and will be created"
                if [ "${task_branch#*"/"}" = "$task_branch" ]; then
                    task_branch="$GIT_MUX_BRANCH_PREFIX/$task_branch"
                    logger "DEBUG" "task > added prefix to branch: $task_branch"
                fi
            fi
        else
            task_branch=$(select_branch)
            logger "INFO " "task > selected branch: $task_branch"
        fi

        task_name="$(sanitize_name "$task_branch")"
        logger "DEBUG" "task > sanitized task name: $task_name"

        # naively assumes a bare repo will be using worktrees
        if [ "$(git rev-parse --is-bare-repository 2>>"$GIT_MUX_LOGS")" = "true" ]; then
            logger "DEBUG" "task > project is bare repo, using git-worktree"
            task_start_dir="$task_start_dir/$task_name"

            logger "INFO " "task > worktree directory: $task_start_dir"
            if [ ! -d "$task_start_dir" ]; then
                logger "INFO " "task > worktree does not exist, adding now"
                # shellcheck disable=2086
                git worktree add $task_name $task_branch_flags $task_branch >&2
                export GIT_MUX_NEW_WORKTREE="1"
            fi
        else
            logger "INFO " "task > checking out branch"
            # shellcheck disable=2086
            git checkout $task_branch_flags $task_branch >&2
        fi

        handle_task "$task_start_dir" \
            "${task_name:-$(sanitize_name "$task_branch")}" "$*"
    fi

    unset task_start_dir task_name task_branch task_branch_flags
}

is_git_root_dir() {
    git_dir="$(git rev-parse --path-format=relative --git-dir 2>>"$GIT_MUX_LOGS")"
    # normal repos
    [ "$git_dir" = ".git" ] ||
        # bare repos
        [ "$git_dir" = "." ] ||
        # just for safsies
        [ "$(git rev-parse --path-format=absolute --show-toplevel 2>>"$GIT_MUX_LOGS")" = "${1:-$(pwd)}" ]
}

# Use $GIT_MUX_SELECT_CMD to select an existing git branch for creating a task.
select_branch() {
    # remote and local branches sorted by commit date
    git for-each-ref refs/remotes refs/heads \
        --sort=-committerdate --format='%(refname:short)' |
        # filter by query, remove 'origin/' prefix, dedupe, select branch
        awk '/'"$GIT_MUX_BRANCH_DEFAULT_QUERY"'/{gsub("^origin/(HEAD)?","")};!x[$0]++' |
        $GIT_MUX_SELECT_CMD
}

# --------------------------------------------------------------------- }}}
# Parse arguments                                                       {{{
# --------------------------------------------------------------------- {|}

main() {
    command="$1"
    if [ -z "$command" ]; then
        logger "INFO " "No command provided, logging usage message and exiting"
        man git-mux
        exit 1
    fi
    shift
    case $command in
        config) log_config_values ;;
        c | clone) bare_clone "$@" ;;
        p | project) handle_project "$@" ;;
        t | task) handle_task "$@" ;;
        h | help | -h | --help) man git-mux ;;
        *)
            logger "ERROR" "invalid command: \"$command\""
            printf "%s \"%s\"\n%s\n" \
                "Error: Invalid command" \
                "$command" \
                "See \`git mux help\` for usage information." >&2
            exit 1
            ;;
    esac
}

# --------------------------------------------------------------------- }}}

# add blank line to separate runs in the logs
logger "\nINFO " "START > args: $*"

main "$@"
